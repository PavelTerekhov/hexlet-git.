// Курс по Git 

Task 1

code-user/
Выполните клонирование репозитория:

# Находясь в той директории, которая загружается автоматически в терминале
# Первый параметр «откуда», второй — «куда»
$ git clone repos/git-user code-user
В репозитории уже есть два файла. Измените их так:

В hexlet.txt добавьте второй строчкой текст I like to change files
В index.html замените текст на <h1>С помощью гит можно писать книги</h1>
Выполните один коммит, содержащий сразу эти два изменения. Во время коммита git попросит установить емейл и имя пользователя. Сделайте это, используя любые вымышленные данные
Добавьте изменения в основной репозиторий с помощью git push
Подсказки
После добавления емейла и имени пользователя нужно повторить коммит, так как предыдущий коммит из-за отсутствия настроек выполнен не был


// # При выполнении задачи состояние репозитория могло измениться.
// # Перед набором команд из списка, обновите упражнение с помощью кнопки Сброс.

// git clone repos/git-user code-user
// cd code-user/
// echo 'I like to change files' >> hexlet.txt
// echo '<h1>С помощью гит можно писать книги</h1>' > index.html
// git add .
// git config --global user.email "you@example.com"
// git config --global user.name "Your Name"
// git commit -m 'fix hexlet.txt and index.html'
// git push


Если файл был удалён, для востановления используются команды для востановления или изменения коммита

// Changes not staged for commit:
//   (use "git add/rm <file>..." to update what will be committed)
//   (use "git restore <file>..." to discard changes in working directory)
//     deleted:    PEOPLE.md


// Можно удалить всю рабочую директорию целиком и потом без проблем восстановить её. Так мы достигаем важной цели — делаем возможным быстрое восстановление последней версии кода, если изменения, которые мы делали, нас больше не устраивают. Или мы можем закоммитить их, если это нужно:

// rm PEOPLE.md
// # Любое изменение обязательно добавлять в индекс
// git add PEOPLE.md
// git commit -m 'remove PEOPLE.md'

// [main e15afd2] remove PEOPLE.md
// 1 file changed, 1 deletion(-)
// delete mode 100644 PEOPLE.md
// # Теперь этот файл пропал из рабочей директории
// Обратите внимание на важную деталь. Независимо от того, удаляем мы файл, добавляем или меняем, процедура выполнения коммита не меняется. После изменений всегда делается git add, который подготавливает изменение к коммиту (а не добавляет файл!), и после этого выполняется коммит.

// Кстати, у git есть команда git rm, которая объединяет в себе удаление и подготовку к коммиту:

// git rm PEOPLE.md
// # равносильно rm + git add


// По умолчанию git diff показывает изменения только для тех модифицированных файлов, которые ещё не были добавлены в индекс. Подразумевается, что добавленные в индекс файлы смотреть не нужно, ведь мы их уже подготовили к коммиту. В реальности же часто хочется и, более того, нужно увидеть эти изменения. Для этого нужно запустить команду вывода дифа с флагом --staged:

// # Выведет все изменения сделанные в рабочей директории
// # которые были добавлены в индекс
// git diff --staged
// git diff — команда, которую нужно обязательно запускать перед каждым коммитом. Она позволяет проанализировать добавляемые изменения и исправить возможные ошибки. Иногда программисты по ошибке добавляют в коммит то, что туда не должно попасть.



Task 2

// code-user/
// Выполните следующие действия:

Удалите файл index.html
Переименуйте файл hexlet.txt в hexlet2.txt
После каждого действия добавляйте изменения в отслеживание и изучайте вывод команды git diff --staged и git status. Обратите внимание на различия вывода последней команды до добавления изменений в индекс и после.
Закоммитьте каждое изменение отдельно.

// cd code-user/ # Переходим в директорию code-user
// rm -f index.html
// git add index.html
// git commit -m 'remove index.html'
// mv hexlet.txt hexlet2.txt
// git add hexlet.txt
// git add hexlet2.txt
// git commit -m 'rename hexlet.txt to hexlet2.txt'



Git Show

// У каждого коммита есть идентификатор (говорят "хеш"), уникальный набор символов. С помощью хеша можно посмотреть все изменения, сделанные в рамках одного коммита:
// Хеши коммитов в git очень длинные, и ими бывает неудобно пользоваться. Поэтому разработчики git добавили возможность указывать только часть хеша. Достаточно взять первые 8 символов и подставить их в ту команду, которая работает с коммитами:
// git show 5120bea3

Git Blame

// А что если мы не знаем коммита, но нам интересно, кто последним менял конкретную строку в файле? Для этого подойдет команда git blame <путь до файла>. Эта команда выводит файл и рядом с каждой строкой показывает того, кто её менял и в каком коммите.
// git blame INFO.md
// e6f625cf (tirion 2020-09-17 16:14:09 -0400 1) git is awesome!
// 5120bea3 (tirion 2020-09-17 18:04:19 -0400 2) new line

Git Grep

// Команда git grep ищет совпадение с указанной строкой во всех файлах проекта. Это очень удобная команда для быстрого анализа из терминала. Она удобнее обычного grep, так как знает про игнорирование и не смотрит в директорию .git, а ещё умеет искать по истории:
// git grep line
// INFO.md:new line
// # Флаг i позволяет искать без учета регистра
// git grep -i hexlet
// README.md:Hello, Hexlet! How are you?
// # Поиск в конкретном коммите
// git grep Hexlet 5120bea3
// # Поиск по всей истории
// # rev-list возвращает список хешей коммитов
// git grep Hexlet $(git rev-list --all)


Неотслеживаемые файлы

// Самая простая ситуация. Вы добавили новые файлы в репозиторий (или сгенерировали их как-то) и поняли, что они вам не нужны. В этом случае можно выполнить очистку:
// mkdir one
// touch two
// git status
// On branch main
// Your branch is up to date with 'origin/main'.
// # Пустые директории в git не добавляются в принципе.
// # Физически директория one находится в рабочей директории,
// # но её нет в git, и он её игнорирует
// Untracked files:
//   (use "git add <file>..." to include in what will be committed)
//     two
// # Выполняем очистку
// # -f – force, -d – directory
// git clean -fd
// Removing one/
// Removing two

Изменения, подготовленные к коммиту

// С файлами, подготовленными к коммиту, можно поступить по-разному. Первый вариант — отменить изменения совсем, второй — отменить только индексацию, не изменяя файлы в рабочей директории. Второе полезно в том случае, если изменения нам нужны, но мы не хотим их коммитить сейчас.
// echo 'new text' > INFO.md
// git add INFO.md
// git status
// On branch main
// Your branch is up to date with 'origin/main'.
// Changes to be committed:
//   (use "git restore --staged <file>..." to unstage)
//     modified:   INFO.md
// И здесь снова помогает Git. При выводе статуса он показывает нужную нам команду для перевода изменений в рабочую директорию:
// git restore --staged INFO.md
// git status
// On branch main
// Your branch is up to date with 'origin/main'.
// Changes not staged for commit:
//   (use "git add <file>..." to update what will be committed)
//   (use "git restore <file>..." to discard changes in working directory)
//     modified:   INFO.md
// Теперь, если нужно, можно выполнить git restore и окончательно отменить изменения в выбранных файлах.


Task 3

// code-user/
// Отмените все изменения, сделанные в рабочей директории и индексе. В результате должен получиться такой вывод:
// $ git status
// nothing to commit, working tree clean

// cd code-user/ # Переходим в директорию code-user
// git restore hexlet.txt
// git restore --staged index.md index.html
// git restore index.html
// git clean -fd


Отмена коммитов

Git revert

// Фактически она сводится к созданию ещё одного коммита, который выполняет изменения противоположные тому коммиту, который отменяется. Руками создавать подобный коммит довольно сложно, поэтому в git добавили команду, автоматизирующую откат. Эта команда называется git revert:
// # Этой команде нужен идентификатор коммита
// # Это коммит, которым мы удалили файл PEOPLE.md
// git revert aa600a43cb164408e4ad87d216bc679d097f1a6c
// # После этой команды откроется редактор, ожидающий ввода описания коммита
// # Обычно сообщение revert не меняют, поэтому достаточно просто закрыть редактор
// [main 65a8ef7] Revert "remove PEOPLE.md"
//  1 file changed, 1 insertion(+)
//  create mode 100644 PEOPLE.md
// # В проект вернулся файл PEOPLE.md

git log -p

// commit 65a8ef7fd56c7356dcee35c2d05b4400f4467ca8
// Author: tirion <tirion@got.com>
// Date:   Sat Sep 26 15:32:46 2020 -0400

//     Revert "remove PEOPLE.md"

//     This reverts commit aa600a43cb164408e4ad87d216bc679d097f1a6c.

// diff --git a/PEOPLE.md b/PEOPLE.md
// new file mode 100644
// index 0000000..4b34ba8
// --- /dev/null
// +++ b/PEOPLE.md
// @@ -0,0 +1 @@
// +Haskell Curry
// Команда revert может "отменять" не только последний коммит, но и любой другой коммит из истории проекта. Согласитесь, это очень круто. Без системы контроля версий о таком нельзя было и мечтать.


// 3 режима команды git reset: --soft, --mixed(по умолчанию), --hard

Git reset

// Иногда удалить нужно только что сделанный по ошибке коммит. Конечно, и в этом случае подходит git revert, но так загрязняется история. Если этот коммит сделан был только сейчас и ещё не отправлялся на Github, то лучше сделать так, как будто бы этого коммита не существовало в принципе.
// Git позволяет удалять коммиты. Это опасная операция, которую нужно делать только в том случае, если речь идет про новые коммиты, которых нет ни у кого, кроме вас.
// Если коммит был отправлен во внешний репозиторий, например, на Github, то менять историю ни в коем случае нельзя, это сломает работу у тех, кто работает с вами над проектом.
// Для удаления коммита используется команда git reset. Делается это так:

// # добавляем новый коммит, который мы сразу же удалим
// echo 'test' >> INFO.md
// git add INFO.md
// git commit -m 'update INFO.md'

// [main 17a77cb] update INFO.md
//  1 file changed, 1 insertion(+)
//  # Важно, что мы не делаем git push

// git reset --hard HEAD~

// HEAD is now at 65a8ef7 Revert "remove PEOPLE.md"

// # Если посмотреть git log, то последнего коммита там больше нет
// git reset — мощная команда, имеющая множество различных флагов и способов работы. С её помощью удаляются или отменяются (без удаления) коммиты, восстанавливаются файлы из истории и так далее. Работа с ней относится к продвинутому использованию git, здесь же мы затрагиваем только самую базу.

// Флаг --hard означает полное удаление. Без него git reset отменит коммит, но не удалит его, а поместит все изменения этого коммита в рабочую директорию, так что с ними можно будет продолжить работать. HEAD~ означает "один коммит от последнего коммита". Если бы мы хотели удалить два последних коммита, то могли бы написать HEAD~2.


Изменение последнего коммита

// Крайне часто разработчики делают коммит и сразу же понимают, что забыли добавить часть файлов через git add. Оставшуюся часть изменений можно дослать следующим коммитом либо, если изменения ещё не были отправлены во внешнюю систему, можно добавить изменения в текущий коммит. Для этого во время коммита добавляется флаг --amend:

// В реальности --amend не добавляет изменения в существующий коммит, этот флаг приводит к откату коммита (через reset) и выполнению нового коммита с новыми данными. Поэтому мы и видим ровно один коммит, хотя команда git commit выполнялась два раза (первый раз — когда сделали ошибочный коммит).

// Для того, чтобы не открывался редактор для ввода описания коммита к команде git commit --amend можно добавить опцию --no-edit. В этом случае описание коммита не изменится.


Индексирование по частям

// В Git существует возможность индексировать не только файлы целиком, но и некоторые их части. Например, если вы сделали в файле simplegit.rb два изменения и хотите добавить в индекс только одно из них, добиться этого в Git очень легко. В поле ввода в режиме интерактивного индексирования введите 5 или p (для выполнения patch). Git спросит у вас какие файлы вы хотите добавить в индекс частично; а затем для каждой части выбранных файлов он будет показывать изменения в ней и спрашивать хотите ли вы добавить в индекс эту часть:

// diff --git a/lib/simplegit.rb b/lib/simplegit.rb
// index dd5ecc4..57399e0 100644
// --- a/lib/simplegit.rb
// +++ b/lib/simplegit.rb
// @@ -22,7 +22,7 @@ class SimpleGit
//    end

//    def log(treeish = 'master')
// -    command("git log -n 25 #{treeish}")
// +    command("git log -n 30 #{treeish}")
//    end

//    def blame(path)
// Stage this hunk [y,n,a,d,/,j,J,g,e,?]?
// В этой точке у вас есть множество вариантов дальнейших действий. Если вы введёте ?, Git отобразит, что именно вы можете сделать:

// Добавить в индекс эту часть [y,n,a,d,/,j,J,g,e,?]? ?
// y - добавить в индекс эту часть
// n - не добавлять в индекс эту часть
// a - добавить в индекс эту и все оставшиеся в этом файле части
// d - не добавлять в индекс эту и все оставшиеся в этом файле части
// g - перейти к некоторой части файла (g - показывает список частей и затем выполняет переход, g<N> - перейти к части N)
// / - найти часть, соответствующую регулярному выражению
// j - отложить принятие решения по этой части, перейти к следующей части, решение по которой не принято
// J - отложить принятие решения по этой части, перейти к следующей части
// k - отложить принятие решения по этой части, перейти к предыдущей части, решение по которой не принято
// K - отложить принятие решения по этой части, перейти к предыдущей части
// s - разбить текущую часть на части меньшего размера
// e - вручную отредактировать текущую часть
// ? - отобразить помощь
// Обычно вы будете вводить y или n, если вы хотите индексировать каждую часть по отдельности, но индексация всех частей в некоторых файлах или откладывание решения по индексацию части также может быть полезным. Если вы добавили в индекс одну часть файла, но не добавили другую, состояние вашего рабочего каталога будет подобно приведённому далее:

// What now> 1
//            staged     unstaged path
//   1:    unchanged        +0/-1 TODO
//   2:        +1/-1      nothing index.html
//   3:        +1/-1        +4/-0 lib/simplegit.rb
// Обратите внимание на состояние файла simplegit.rb. Оно говорит вам, что часть строк файла добавлена в индекс, а часть нет. Таким образом, вы частично проиндексировали этот файл. В данный момент вы можете выйти из интерактивного режима команды git add и выполнить git commit, чтобы зафиксировать частично проиндексированные файлы.

// Также вам не обязательно находиться в интерактивном режиме индексирования файлов для выполнения частичной индексации файлов — вы также можете запустить её, используя команды git add -p или git add --patch.

// Более того, вы можете использовать работу с отдельными частями файлов для частичного восстановления файлов с помощью команды reset --patch, для переключения частей файлов с помощью команды checkout --patch и для припрятывания частей файлов с помощью stash save --patch. Мы рассмотрим каждую из этих команд более подробно, когда будем изучать более продвинутые варианты их использования.


Task 4

В файл hexlet.txt было добавлено несколько строк. Используя интерактивный режим git add, разбейте изменения на две части и затем добавьте в индекс одну из них. Выведите на экран состояние изменений подготовленных к коммиту в интерактивном режиме с помощью status. Сделайте коммит, в комментарии которого напишите значение из столбца staged.

Подсказки
pwd – текущая директория
cd – переход в другую директорию
Чтобы вывести status в интерактивном режиме git add используйте 1 или s.
После того как мы выбрали файл с помощью patch, он отмечается *. Так как можно выбрать не один файл, а несколько. Подтвердить выбор можно нажатием Enter
Интерактивное индексирование

// cd code-user/ # Переходим в директорию code-user
// git add -i
// patch
// 1
// # Подтверждаем выбор нажатием Enter
// s
// y
// n
// status
// quit
// git commit -m '+2/-0'



Перемещение по истории

// Git позволяет не только просматривать историю, но и перемещаться по ней, загружая в рабочую директорию состояние кода на момент выполнения любого коммита. Посмотрим:
// # Показывает сокращенный вывод
// git log --oneline
// fc74e2d update README.md
// 65a8ef7 Revert "remove PEOPLE.md"
// 5120bea add new content
// e6f625c add INFO.md
// 273f81c remove NEW.md
// aa600a4 remove PEOPLE.md
// fe9893b add NEW.md
// 3ce3c02 add PEOPLE.md
// 3c5d976 add README.md

// Переключимся на момент, когда был выполнен коммит с сообщением add INFO.md. Для этого используется команда git checkout <хеш коммита>:
// git checkout e6f625c
// Note: switching to 'e6f625c'.
// You are in 'detached HEAD' state. You can look around, make experimental
// changes and commit them, and you can discard any commits you make in this
// state without impacting any branches by switching back to a branch.
// Or undo this operation with:
//   git switch -

// Выполните команду выше (хеш вашего коммита может отличаться) и изучите рабочую директорию. Вы увидите, что пропала часть изменений из-за возврата в прошлое. Сами изменения никуда не делись, и мы снова можем вернуться на последний коммит следующей командой:
// # Что такое main, мы поговорим позже
// git checkout main
// Переключившись в нужный коммит, можно не только изучить содержимое репозитория, но и забрать какие-то изменения, которые были удалены, но снова понадобились для работы. Для этого достаточно их скопировать, переключиться на последний коммит и вставить в нужный файл.

// Где я
// Переключение по коммитам отражается только на содержимом рабочей директории. Больше нигде не видно, где мы находимся. Из-за этого немало программистов, забыв где они находятся, начинают работать и очень удивляются, когда не получается выполнить коммит.

// Самый простой способ узнать место нахождения — вызвать команду git branch. В обычной ситуации, когда мы находимся на последнем коммите, git покажет такой вывод:

// git branch

// # О том, что такое main, мы поговорим позже
// * main
// Но если прямо сейчас загружен коммит из прошлого, то вывод станет таким:

// * (HEAD detached at e6f625c)
//   main
// Такой способ проверки текущего местоположения требует постоянного внимания. Нужно не забывать его использовать и, конечно же, все забывают это делать. Гораздо надежнее и удобнее вывести текущее местоположение прямо в командной строке. Например, так:

// # Если на последнем коммите
// hexlet-git git:(main)

// # Если на коммите из прошлого
// hexlet-git git:(e6f625c)
// Именно так делают большинство профессиональных разработчиков. Как добиться такого вывода? Ответ на этот вопрос зависит от используемого командного интерпретатора. В Bash вывод местоположения происходит благодаря редактированию переменной окружения $PS1, подробнее об этом вы можете почитать по ссылке в дополнительных материалах.


Task 5

Вы сделали несколько коммитов в репозиторий, и в каком-то из них сохранили файл todo.md со списком задач, а потом удалили этот файл. Загвоздка в том, что в комментарии к коммиту добавление этого файла отражено не было.
Найдите в истории коммит, в котором был добавлен файл todo.md, и переключитесь на него с помощью git checkout.
Подсказки
pwd – текущая директория
cd – переход в другую директорию
Если добавить имя файла в конец команды git log, отделив его знаками --, можно увидеть в каких коммитах он изменялся

// cd code-user/ # Переходим в директорию code-user
// git log -p --oneline -- todo.md
// git checkout 7c2fcf8

// # Альтернативный вариант решения использовать опцию --name-status
// # git log --name-status
// # Метка "A" перед файлом, сокращение от "Added"

Task 6

В репозитории создано 2 дополнительные ветки, помимо master.
Переключитесь на ветку refactoring и удалите два последних коммита с помощью git reset --hard.
В ветке working-on-html сделайте коммит, отредактировав файл index.html следующим образом:
Замените содержимое тега h1 на «Ветки в Git достойны отдельного курса»
Замените содержимое тега p на «Ветки являются ссылками на определённый коммит.»
Текст размещайте без кавычек.
Подсказки
pwd – текущая директория
cd – переход в другую директорию
git switch branch – переключение на ветку с именем branch


// cd code-user/ # Переходим в директорию code-user
// git switch refactoring
// git reset --hard HEAD~2
// git switch working-on-html
// vim index.html # Редактируем и сохраняем файл
// git add index.html
// git commit -m 'fix index.html'


Игнорирование файлов (Gitignore)

// В процессе работы над любым проектом в директории с кодом создаются файлы, которые не являются частью исходного кода. Все эти файлы можно условно разделить на несколько групп:

// Инструментарий

// Служебные файлы, добавляемые операционной системой (.DS_Store в Mac)
// Конфигурационные и временные файлы редакторов (например, .idea, .vscode)
// Временные файлы

// Логи. В них содержится полезная информация для отладки, которая собирается во время запуска и работы приложения
// Кеши. Файлы, которые нужны для ускорения разных процессов
// Артефакты

// Результаты сборки проекта. Например, после компиляции или сборки фронтенда
// Устанавливаемые во время разработки зависимости (например, node_modules, vendor)
// Результаты выполнения тестов (например, информация о покрытии кода тестами)
// Всё это в обычной ситуации не должно попадать в репозиторий. Как правило, эти файлы не несут никакой пользы с точки зрения исходного кода. Они создаются либо автоматически (кеши, логи), либо по запросу (например, скачиваются зависимости или собирается проект). Главная проблема с этими файлами в их постоянном изменении при, как правило, очень больших размерах. Если добавлять их в репозиторий, то практически в каждом коммите, кроме изменений исходного кода, будет и пачка изменений в этих файлах. Читать историю таких коммитов крайне сложно.

// Git позволяет гибко настраивать игнорирование определенных файлов и директорий. Делается это с помощью файла .gitignore, который нужно создать в корне проекта. В этот файл добавляются файлы и директории, которые надо игнорировать. Например:

// # В этом файле можно оставлять комментарии
// # Имя файла .gitignore
// # Файл нужно создать самостоятельно

// # Каждая строчка — это шаблон, по которому происходит игнорирование

// # Игнорируется файл в любой директории проекта
// access.log

// # Игнорируется директория в любой директории проекта
// node_modules

// # Игнорируется каталог в корне рабочей директории
// /coverage

// # Игнорируются все файлы с расширением sqlite3 в директории db,
// # но не игнорируются такие же файлы внутри любого вложенного каталога в db
// # например, /db/something/lala.sqlite3
// /db/*.sqlite3

// # игнорировать все .txt файлы в каталоге doc/
// # на всех уровнях вложенности
// doc/**/*.txt
// Git поддерживает игнорирование файлов, но сам его не настраивает. Для игнорирования файлов и директорий, программист должен создать файл .gitignore в корне проекта, например как тут и добавить его в репозиторий.

// touch .gitignore
// # добавляем в файл правила игнорирования по примеру выше
// git add .gitignore
// git commit -m 'update gitignore'
// Как только .gitignore создан и в него добавлен какой-то файл или директория, игнорирование заработает автоматически. Все новые файлы, попадающие под игнорирование, не отобразятся в выводе команды git status.

// Иногда бывает такое, что программист случайно уже добавил в репозиторий файл, который нужно проигнорировать. В этой ситуации недостаточно обновить правила игнорирования. Дополнительно придется удалить файл или директорию из git с помощью git rm и закоммитить.


Task 7

Проигнорируйте и удалите из репозитория, если это необходимо, но не удаляйте из рабочей директории, файлы notes.txt и todo.md, а затем сделайте коммит со всеми изменениями.
Подсказки
pwd – текущая директория
cd – переход в другую директорию
Файл .gitignore уже создан и находится в директории code-user
У git rm есть опция --cached. Если её использовать, файл будет удалён из репозитория, но не из рабочей директории

// cd code-user/ # Переходим в директорию code-user
// echo 'notes.txt' > .gitignore
// echo 'todo.md' >> .gitignore
// git rm --cached notes.txt
// git commit -m 'remove notes.txt from repo'
// git add hexlet.txt
// git commit -m 'update hexlet.txt'
// git add .gitignore
// git commit -m 'add .gitignore'



// - .gitignore

// # BEGIN
// notes.txt
// todo.md
// # END


Stash

// Представьте себе ситуацию. Вы работаете над какой-то важной задачей и исправили довольно много файлов. В этот момент появляется срочная задача — сделать какое-то изменение в исходном коде, не связанное с тем, над чем вы сейчас работаете. Ваши изменения ещё не готовы и они не должны попасть в репозиторий. Что делать?
// В самом простом случае, если ваши изменения не пересекаются с изменениями по срочной задаче, вы можете внести исправления, добавить их в индекс, закоммитить и запушить. Но обычно это неудобно и не всегда возможно. А если изменения нужно делать в тех файлах, с которыми вы работаете прямо сейчас?
// Подобная ситуация у опытных разработчиков встречается регулярно и, к счастью, она легко решается. В git существует набор команд, позволяющий «прятать» изменения в рабочей директории и восстанавливать их при необходимости. Попробуем:

// touch FILE.md
// git add FILE.md
// git status

// On branch main
// Your branch is up to date with 'origin/main'.

// Changes to be committed:
//   (use "git restore --staged <file>..." to unstage)
//     new file:   FILE.md

// # Прячем файлы. После этой команды пропадут все изменённые файлы
// # независимо от того, добавлены они в индекс или нет
// git stash

// Saved working directory and index state WIP on main: e7bb5e5 update README.md

// git status

// On branch main
// Your branch is up to date with 'origin/main'.

// nothing to commit, working tree clean
// git stash не удаляет файлы, они попадают в специальное место внутри директории .git «на сохранение». Эта команда не трогает новые файлы, так как они ещё не являются частью репозитория.

// git stash

// После выполнения всех нужных изменений на чистой рабочей директории можно вернуть спрятанные изменения с помощью команды git stash pop:

// # Восстанавливаем
// git stash pop

// On branch main
// Your branch is up to date with 'origin/main'.

// Changes to be committed:
//   (use "git restore --staged <file>..." to unstage)
//     new file:   FILE.md

// Dropped refs/stash@{0} (b896d4a0126ef4409ede63857e5d996953fe75c5)

// # Проверяем
// git status

// On branch main
// Your branch is up to date with 'origin/main'.

// Changes to be committed:
//   (use "git restore --staged <file>..." to unstage)
//     new file:   FILE.md
// Файлы вернулись в том виде, в котором они попали в стеш (stash).

// Stash в Git работает по принципу стека. Он позволяет сохранить внутрь любое количество изменений и восстановить их в обратном порядке:

// git stash

// # изменяем файлы
// git stash

// # Вернутся последние изменения
// git stash pop

// # Вернутся предпоследние изменения
// git stash pop

Task 8

В рабочей директории уже есть изменения, сохраните их с помощью git stash.

Создайте файл todo.md с любым содержимым
Добавьте в файл hexlet.txt строку: «stash не трогает новые файлы, которые ещё не добавлены в индекс.»
Сделайте коммит
Восстановите сохранённые ранее изменения
Сделайте еще один коммит, включающий и новые файлы
Подсказки
pwd – текущая директория
cd – переход в другую директорию
Строку в файл hexlet.txt нужно добавлять без кавычек


// cd code-user/ # Переходим в директорию code-user
// git add . # Так как есть изменения не добавленные в индекс
// git stash
// echo 'Hexlet is awesome!' > todo.md
// echo 'stash не трогает новые файлы, которые ещё не добавлены в индекс.' >> hexlet.txt
// git add .
// git commit -m 'refactoring'
// git stash pop
// git commit -am 'changes from stash'